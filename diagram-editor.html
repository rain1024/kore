<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Diagram Editor - Figma-like with Animated Arrows</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: #1e1e1e;
            color: #fff;
            height: 100vh;
            overflow: hidden;
        }

        .app {
            display: flex;
            height: 100vh;
        }

        /* Left Sidebar - Shapes */
        .sidebar {
            width: 60px;
            background: #2d2d2d;
            border-right: 1px solid #404040;
            display: flex;
            flex-direction: column;
            padding: 10px 0;
        }

        .sidebar-item {
            width: 40px;
            height: 40px;
            margin: 5px auto;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            border-radius: 8px;
            transition: background 0.2s;
            color: #999;
        }

        .sidebar-item:hover {
            background: #404040;
            color: #fff;
        }

        .sidebar-item.active {
            background: #0066ff;
            color: #fff;
        }

        .sidebar-item svg {
            width: 24px;
            height: 24px;
        }

        .divider {
            height: 1px;
            background: #404040;
            margin: 10px 5px;
        }

        /* Main Canvas Area */
        .canvas-container-wrapper {
            flex: 1;
            background: #1a1a1a;
            position: relative;
            overflow: hidden;
        }

        .canvas-container {
            width: 100%;
            height: 100%;
        }

        #canvas {
            background: #2d2d2d;
        }

        /* Right Properties Panel */
        .properties-panel {
            width: 250px;
            background: #2d2d2d;
            border-left: 1px solid #404040;
            padding: 15px;
            overflow-y: auto;
        }

        .panel-title {
            font-size: 12px;
            font-weight: 600;
            color: #999;
            text-transform: uppercase;
            margin-bottom: 15px;
        }

        .property-group {
            margin-bottom: 20px;
        }

        .property-label {
            font-size: 11px;
            color: #888;
            margin-bottom: 5px;
        }

        .property-row {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        .property-input {
            flex: 1;
            background: #1e1e1e;
            border: 1px solid #404040;
            border-radius: 4px;
            padding: 8px;
            color: #fff;
            font-size: 12px;
        }

        .property-input:focus {
            outline: none;
            border-color: #0066ff;
        }

        .color-input-wrapper {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .color-input {
            width: 30px;
            height: 30px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            background: none;
        }

        .btn {
            background: #0066ff;
            color: #fff;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            width: 100%;
            margin-bottom: 8px;
            transition: background 0.2s;
        }

        .btn:hover {
            background: #0052cc;
        }

        .btn-secondary {
            background: #404040;
        }

        .btn-secondary:hover {
            background: #505050;
        }

        .btn-danger {
            background: #cc3333;
        }

        .btn-danger:hover {
            background: #aa2222;
        }

        /* Arrow Animation Settings */
        .animation-controls {
            background: #1e1e1e;
            border-radius: 8px;
            padding: 12px;
            margin-top: 10px;
        }

        .animation-toggle {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }

        .toggle-switch {
            width: 40px;
            height: 20px;
            background: #404040;
            border-radius: 10px;
            position: relative;
            cursor: pointer;
            transition: background 0.3s;
        }

        .toggle-switch.active {
            background: #0066ff;
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            width: 16px;
            height: 16px;
            background: #fff;
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: transform 0.3s;
        }

        .toggle-switch.active::after {
            transform: translateX(20px);
        }

        .slider-container {
            margin-top: 10px;
        }

        .slider {
            width: 100%;
            margin-top: 5px;
        }

        /* Top Toolbar */
        .top-toolbar {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: #2d2d2d;
            border-radius: 8px;
            padding: 8px;
            display: flex;
            gap: 5px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            z-index: 100;
        }

        .toolbar-btn {
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: none;
            background: transparent;
            color: #999;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .toolbar-btn:hover {
            background: #404040;
            color: #fff;
        }

        .toolbar-btn.active {
            background: #0066ff;
            color: #fff;
        }

        /* Help Tooltip */
        .help-tooltip {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: #404040;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 12px;
            color: #ccc;
            z-index: 1000;
        }

        /* Connection Points */
        .connection-point {
            fill: #0066ff;
            stroke: #fff;
            stroke-width: 2;
            cursor: crosshair;
        }

        /* Arrow Animation Overlay */
        .arrow-animation-layer {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 50;
        }

        @keyframes flowAnimation {
            from {
                stroke-dashoffset: 20;
            }
            to {
                stroke-dashoffset: 0;
            }
        }

        .animated-arrow {
            stroke-dasharray: 10, 10;
            animation: flowAnimation 0.5s linear infinite;
        }

        /* Context Menu */
        .context-menu {
            position: fixed;
            background: #2d2d2d;
            border: 1px solid #404040;
            border-radius: 8px;
            padding: 5px 0;
            min-width: 150px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            z-index: 1000;
            display: none;
        }

        .context-menu-item {
            padding: 8px 15px;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .context-menu-item:hover {
            background: #404040;
        }

        .context-menu-divider {
            height: 1px;
            background: #404040;
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <div class="app">
        <!-- Left Sidebar -->
        <div class="sidebar">
            <div class="sidebar-item" data-tool="select" title="Select (V)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z"/>
                </svg>
            </div>
            <div class="divider"></div>
            <div class="sidebar-item" data-shape="rect" title="Rectangle (R)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <rect x="3" y="3" width="18" height="18" rx="2"/>
                </svg>
            </div>
            <div class="sidebar-item" data-shape="circle" title="Circle (O)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="9"/>
                </svg>
            </div>
            <div class="sidebar-item" data-shape="triangle" title="Triangle (T)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M12 3L22 21H2L12 3z"/>
                </svg>
            </div>
            <div class="sidebar-item" data-shape="diamond" title="Diamond (D)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M12 2L22 12L12 22L2 12L12 2z"/>
                </svg>
            </div>
            <div class="divider"></div>
            <div class="sidebar-item" data-shape="text" title="Text (T)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M4 7V4h16v3M9 20h6M12 4v16"/>
                </svg>
            </div>
            <div class="divider"></div>
            <div class="sidebar-item" data-tool="arrow" title="Arrow Connection (A)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M5 12h14M12 5l7 7-7 7"/>
                </svg>
            </div>
            <div class="sidebar-item" data-tool="line" title="Line (L)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <line x1="5" y1="19" x2="19" y2="5"/>
                </svg>
            </div>
        </div>

        <!-- Main Canvas -->
        <div class="canvas-container-wrapper">
            <div class="top-toolbar">
                <button class="toolbar-btn" id="zoomOut" title="Zoom Out">
                    <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/><line x1="8" y1="11" x2="14" y2="11"/>
                    </svg>
                </button>
                <button class="toolbar-btn" id="zoomReset" title="Reset Zoom">100%</button>
                <button class="toolbar-btn" id="zoomIn" title="Zoom In">
                    <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/><line x1="11" y1="8" x2="11" y2="14"/><line x1="8" y1="11" x2="14" y2="11"/>
                    </svg>
                </button>
                <div style="width:1px;background:#404040;margin:0 5px;"></div>
                <button class="toolbar-btn" id="undo" title="Undo (Ctrl+Z)">
                    <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M3 7v6h6"/><path d="M3 13c0-4.97 4.03-9 9-9s9 4.03 9 9-4.03 9-9 9c-2.12 0-4.07-.74-5.61-1.97"/>
                    </svg>
                </button>
                <button class="toolbar-btn" id="redo" title="Redo (Ctrl+Y)">
                    <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 7v6h-6"/><path d="M21 13c0-4.97-4.03-9-9-9s-9 4.03-9 9 4.03 9 9 9c2.12 0 4.07-.74 5.61-1.97"/>
                    </svg>
                </button>
            </div>
            <canvas id="canvas"></canvas>
            <svg class="arrow-animation-layer" id="animationLayer"></svg>
        </div>

        <!-- Right Properties Panel -->
        <div class="properties-panel">
            <div class="panel-title">Properties</div>

            <div id="noSelection" class="property-group">
                <p style="color:#666;font-size:12px;">Select an object to edit its properties</p>
            </div>

            <div id="objectProperties" style="display:none;">
                <div class="property-group">
                    <div class="property-label">Position</div>
                    <div class="property-row">
                        <input type="number" class="property-input" id="propX" placeholder="X">
                        <input type="number" class="property-input" id="propY" placeholder="Y">
                    </div>
                </div>

                <div class="property-group">
                    <div class="property-label">Size</div>
                    <div class="property-row">
                        <input type="number" class="property-input" id="propWidth" placeholder="W">
                        <input type="number" class="property-input" id="propHeight" placeholder="H">
                    </div>
                </div>

                <div class="property-group">
                    <div class="property-label">Rotation</div>
                    <div class="property-row">
                        <input type="number" class="property-input" id="propRotation" placeholder="0Â°">
                    </div>
                </div>

                <div class="property-group">
                    <div class="property-label">Fill Color</div>
                    <div class="color-input-wrapper">
                        <input type="color" class="color-input" id="propFill" value="#4a9eff">
                        <input type="text" class="property-input" id="propFillText" value="#4a9eff">
                    </div>
                </div>

                <div class="property-group">
                    <div class="property-label">Stroke Color</div>
                    <div class="color-input-wrapper">
                        <input type="color" class="color-input" id="propStroke" value="#ffffff">
                        <input type="text" class="property-input" id="propStrokeText" value="#ffffff">
                    </div>
                </div>

                <div class="property-group">
                    <div class="property-label">Stroke Width</div>
                    <input type="number" class="property-input" id="propStrokeWidth" value="2" min="0" max="20">
                </div>

                <div class="property-group" id="textProperties" style="display:none;">
                    <div class="property-label">Font Size</div>
                    <input type="number" class="property-input" id="propFontSize" value="20" min="8" max="200">
                </div>

                <button class="btn btn-danger" id="deleteObject">Delete Object</button>
            </div>

            <div id="arrowProperties" style="display:none;">
                <div class="property-group">
                    <div class="property-label">Arrow Style</div>
                    <select class="property-input" id="arrowStyle">
                        <option value="solid">Solid</option>
                        <option value="dashed">Dashed</option>
                        <option value="dotted">Dotted</option>
                    </select>
                </div>

                <div class="property-group">
                    <div class="property-label">Stroke Color</div>
                    <div class="color-input-wrapper">
                        <input type="color" class="color-input" id="arrowColor" value="#4a9eff">
                        <input type="text" class="property-input" id="arrowColorText" value="#4a9eff">
                    </div>
                </div>

                <div class="property-group">
                    <div class="property-label">Stroke Width</div>
                    <input type="number" class="property-input" id="arrowWidth" value="3" min="1" max="10">
                </div>

                <div class="animation-controls">
                    <div class="property-label">Animation</div>
                    <div class="animation-toggle">
                        <div class="toggle-switch" id="animationToggle"></div>
                        <span style="font-size:12px;">Enable Flow Animation</span>
                    </div>
                    <div class="slider-container" id="speedContainer" style="display:none;">
                        <div class="property-label">Speed</div>
                        <input type="range" class="slider" id="animationSpeed" min="0.1" max="3" step="0.1" value="1">
                    </div>
                </div>

                <button class="btn btn-danger" id="deleteArrow">Delete Arrow</button>
            </div>

            <div class="divider" style="margin: 20px 0;"></div>

            <div class="panel-title">Actions</div>
            <button class="btn" id="exportPNG">Export as PNG</button>
            <button class="btn btn-secondary" id="exportJSON">Export as JSON</button>
            <button class="btn btn-secondary" id="importJSON">Import JSON</button>
            <button class="btn btn-secondary" id="clearCanvas">Clear Canvas</button>
            <input type="file" id="jsonFileInput" accept=".json" style="display:none;">
        </div>
    </div>

    <!-- Context Menu -->
    <div class="context-menu" id="contextMenu">
        <div class="context-menu-item" data-action="duplicate">
            <span>Duplicate</span>
        </div>
        <div class="context-menu-item" data-action="bringToFront">
            <span>Bring to Front</span>
        </div>
        <div class="context-menu-item" data-action="sendToBack">
            <span>Send to Back</span>
        </div>
        <div class="context-menu-divider"></div>
        <div class="context-menu-item" data-action="delete" style="color:#ff6666;">
            <span>Delete</span>
        </div>
    </div>

    <!-- Help Tooltip -->
    <div class="help-tooltip" id="helpTooltip">
        Double-click text to edit | Hold Shift to draw from center | Press Delete to remove selected
    </div>

    <script>
        // Initialize Fabric.js canvas
        const canvasEl = document.getElementById('canvas');
        const container = document.querySelector('.canvas-container-wrapper');

        // Set canvas size
        function resizeCanvas() {
            const rect = container.getBoundingClientRect();
            canvasEl.width = rect.width;
            canvasEl.height = rect.height;
            if (canvas) {
                canvas.setDimensions({ width: rect.width, height: rect.height });
                canvas.renderAll();
            }
            // Update animation layer size
            const animLayer = document.getElementById('animationLayer');
            animLayer.setAttribute('width', rect.width);
            animLayer.setAttribute('height', rect.height);
        }

        const canvas = new fabric.Canvas('canvas', {
            backgroundColor: '#1a1a1a',
            selection: true,
            preserveObjectStacking: true
        });

        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // State management
        let currentTool = 'select';
        let isDrawingArrow = false;
        let arrowStartPoint = null;
        let arrowStartObject = null;
        let tempLine = null;
        let arrows = [];
        let zoomLevel = 1;
        let history = [];
        let historyIndex = -1;

        // Default colors
        const defaultFill = '#4a9eff';
        const defaultStroke = '#ffffff';

        // Tool selection
        document.querySelectorAll('.sidebar-item').forEach(item => {
            item.addEventListener('click', () => {
                const tool = item.dataset.tool;
                const shape = item.dataset.shape;

                document.querySelectorAll('.sidebar-item').forEach(i => i.classList.remove('active'));
                item.classList.add('active');

                if (tool) {
                    currentTool = tool;
                    canvas.selection = tool === 'select';
                    canvas.forEachObject(obj => {
                        obj.selectable = tool === 'select';
                    });
                    if (tool === 'select') {
                        canvas.defaultCursor = 'default';
                    } else {
                        canvas.defaultCursor = 'crosshair';
                    }
                } else if (shape) {
                    addShape(shape);
                    // Switch back to select tool after adding shape
                    currentTool = 'select';
                    document.querySelector('[data-tool="select"]').classList.add('active');
                    item.classList.remove('active');
                }
            });
        });

        // Add shapes
        function addShape(type) {
            let shape;
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;

            switch (type) {
                case 'rect':
                    shape = new fabric.Rect({
                        left: centerX - 60,
                        top: centerY - 40,
                        width: 120,
                        height: 80,
                        fill: defaultFill,
                        stroke: defaultStroke,
                        strokeWidth: 2,
                        rx: 8,
                        ry: 8
                    });
                    break;
                case 'circle':
                    shape = new fabric.Circle({
                        left: centerX - 50,
                        top: centerY - 50,
                        radius: 50,
                        fill: defaultFill,
                        stroke: defaultStroke,
                        strokeWidth: 2
                    });
                    break;
                case 'triangle':
                    shape = new fabric.Triangle({
                        left: centerX - 50,
                        top: centerY - 43,
                        width: 100,
                        height: 86,
                        fill: defaultFill,
                        stroke: defaultStroke,
                        strokeWidth: 2
                    });
                    break;
                case 'diamond':
                    shape = new fabric.Polygon([
                        { x: 50, y: 0 },
                        { x: 100, y: 50 },
                        { x: 50, y: 100 },
                        { x: 0, y: 50 }
                    ], {
                        left: centerX - 50,
                        top: centerY - 50,
                        fill: defaultFill,
                        stroke: defaultStroke,
                        strokeWidth: 2
                    });
                    break;
                case 'text':
                    shape = new fabric.IText('Double-click to edit', {
                        left: centerX - 80,
                        top: centerY - 15,
                        fontSize: 20,
                        fill: '#ffffff',
                        fontFamily: 'Arial'
                    });
                    break;
            }

            if (shape) {
                shape.set({
                    id: 'shape_' + Date.now(),
                    cornerColor: '#0066ff',
                    cornerStrokeColor: '#0066ff',
                    borderColor: '#0066ff',
                    cornerSize: 10,
                    transparentCorners: false,
                    cornerStyle: 'circle'
                });
                canvas.add(shape);
                canvas.setActiveObject(shape);
                canvas.renderAll();
                saveState();
            }
        }

        // Arrow drawing functionality
        canvas.on('mouse:down', function(opt) {
            if (currentTool === 'arrow' || currentTool === 'line') {
                isDrawingArrow = true;
                const pointer = canvas.getPointer(opt.e);
                arrowStartPoint = { x: pointer.x, y: pointer.y };

                // Check if clicking on an object
                const target = canvas.findTarget(opt.e);
                if (target && target.type !== 'line' && target.type !== 'path') {
                    arrowStartObject = target;
                    const objCenter = target.getCenterPoint();
                    arrowStartPoint = { x: objCenter.x, y: objCenter.y };
                }

                // Create temporary line
                tempLine = new fabric.Line([arrowStartPoint.x, arrowStartPoint.y, arrowStartPoint.x, arrowStartPoint.y], {
                    stroke: '#4a9eff',
                    strokeWidth: 3,
                    selectable: false,
                    evented: false,
                    strokeDashArray: currentTool === 'line' ? null : [10, 5]
                });
                canvas.add(tempLine);
            }
        });

        canvas.on('mouse:move', function(opt) {
            if (isDrawingArrow && tempLine) {
                const pointer = canvas.getPointer(opt.e);
                tempLine.set({ x2: pointer.x, y2: pointer.y });
                canvas.renderAll();
            }
        });

        canvas.on('mouse:up', function(opt) {
            if (isDrawingArrow && tempLine) {
                const pointer = canvas.getPointer(opt.e);
                const endPoint = { x: pointer.x, y: pointer.y };

                // Check if ending on an object
                let arrowEndObject = null;
                const target = canvas.findTarget(opt.e);
                if (target && target !== tempLine && target.type !== 'line' && target.type !== 'path') {
                    arrowEndObject = target;
                    const objCenter = target.getCenterPoint();
                    endPoint.x = objCenter.x;
                    endPoint.y = objCenter.y;
                }

                canvas.remove(tempLine);

                // Only create arrow if there's actual distance
                const distance = Math.sqrt(
                    Math.pow(endPoint.x - arrowStartPoint.x, 2) +
                    Math.pow(endPoint.y - arrowStartPoint.y, 2)
                );

                if (distance > 20) {
                    createArrow(arrowStartPoint, endPoint, arrowStartObject, arrowEndObject, currentTool === 'arrow');
                }

                isDrawingArrow = false;
                arrowStartPoint = null;
                arrowStartObject = null;
                tempLine = null;
            }
        });

        // Create arrow with optional animation
        function createArrow(start, end, startObj, endObj, hasArrowHead = true) {
            const angle = Math.atan2(end.y - start.y, end.x - start.x);
            const headLength = 15;

            let pathData;
            if (hasArrowHead) {
                // Arrow with head
                const arrowHead1 = {
                    x: end.x - headLength * Math.cos(angle - Math.PI / 6),
                    y: end.y - headLength * Math.sin(angle - Math.PI / 6)
                };
                const arrowHead2 = {
                    x: end.x - headLength * Math.cos(angle + Math.PI / 6),
                    y: end.y - headLength * Math.sin(angle + Math.PI / 6)
                };

                pathData = `M ${start.x} ${start.y} L ${end.x} ${end.y} M ${end.x} ${end.y} L ${arrowHead1.x} ${arrowHead1.y} M ${end.x} ${end.y} L ${arrowHead2.x} ${arrowHead2.y}`;
            } else {
                pathData = `M ${start.x} ${start.y} L ${end.x} ${end.y}`;
            }

            const arrow = new fabric.Path(pathData, {
                stroke: '#4a9eff',
                strokeWidth: 3,
                fill: null,
                selectable: true,
                id: 'arrow_' + Date.now(),
                customType: 'arrow',
                hasArrowHead: hasArrowHead,
                startPoint: { ...start },
                endPoint: { ...end },
                startObject: startObj ? startObj.id : null,
                endObject: endObj ? endObj.id : null,
                animated: false,
                animationSpeed: 1,
                // Hide default controls for arrows
                hasBorders: false,
                hasControls: true,
                lockMovementX: true,
                lockMovementY: true,
                cornerColor: '#0066ff',
                cornerStrokeColor: '#fff',
                cornerSize: 12,
                transparentCorners: false,
                objectCaching: false
            });

            // Apply custom endpoint controls
            setupArrowControls(arrow);

            canvas.add(arrow);
            arrows.push(arrow);
            canvas.setActiveObject(arrow);
            canvas.renderAll();
            saveState();

            return arrow;
        }

        // Custom diamond control renderer
        function renderDiamondControl(ctx, left, top, styleOverride, fabricObject) {
            const size = 10;
            ctx.save();
            ctx.translate(left, top);
            ctx.rotate(Math.PI / 4);
            ctx.fillStyle = '#fff';
            ctx.strokeStyle = '#0066ff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.rect(-size / 2, -size / 2, size, size);
            ctx.fill();
            ctx.stroke();
            ctx.restore();
        }

        // Setup custom controls for arrows (endpoint handles)
        function setupArrowControls(arrow) {
            // Remove all default controls
            arrow.controls = {};

            // Start point control (diamond)
            arrow.controls.startPoint = new fabric.Control({
                positionHandler: function(dim, finalMatrix, fabricObject) {
                    const start = fabricObject.startPoint;
                    return fabric.util.transformPoint(
                        { x: start.x, y: start.y },
                        canvas.viewportTransform
                    );
                },
                actionHandler: function(eventData, transform, x, y) {
                    const target = transform.target;
                    const pointer = canvas.getPointer(eventData);

                    // Update start point
                    target.startPoint = { x: pointer.x, y: pointer.y };

                    // Rebuild arrow path
                    rebuildArrowPath(target);
                    canvas.renderAll();
                    return true;
                },
                cursorStyle: 'move',
                render: renderDiamondControl
            });

            // End point control (diamond)
            arrow.controls.endPoint = new fabric.Control({
                positionHandler: function(dim, finalMatrix, fabricObject) {
                    const end = fabricObject.endPoint;
                    return fabric.util.transformPoint(
                        { x: end.x, y: end.y },
                        canvas.viewportTransform
                    );
                },
                actionHandler: function(eventData, transform, x, y) {
                    const target = transform.target;
                    const pointer = canvas.getPointer(eventData);

                    // Update end point
                    target.endPoint = { x: pointer.x, y: pointer.y };

                    // Rebuild arrow path
                    rebuildArrowPath(target);
                    canvas.renderAll();
                    return true;
                },
                cursorStyle: 'move',
                render: renderDiamondControl
            });
        }

        // Rebuild arrow path when endpoints change
        function rebuildArrowPath(arrow) {
            const start = arrow.startPoint;
            const end = arrow.endPoint;
            const angle = Math.atan2(end.y - start.y, end.x - start.x);
            const headLength = 15;

            let pathData;
            if (arrow.hasArrowHead) {
                const arrowHead1 = {
                    x: end.x - headLength * Math.cos(angle - Math.PI / 6),
                    y: end.y - headLength * Math.sin(angle - Math.PI / 6)
                };
                const arrowHead2 = {
                    x: end.x - headLength * Math.cos(angle + Math.PI / 6),
                    y: end.y - headLength * Math.sin(angle + Math.PI / 6)
                };
                pathData = `M ${start.x} ${start.y} L ${end.x} ${end.y} M ${end.x} ${end.y} L ${arrowHead1.x} ${arrowHead1.y} M ${end.x} ${end.y} L ${arrowHead2.x} ${arrowHead2.y}`;
            } else {
                pathData = `M ${start.x} ${start.y} L ${end.x} ${end.y}`;
            }

            // Create new path and update arrow
            const newPath = new fabric.Path(pathData);
            arrow.path = newPath.path;
            arrow.dirty = true;

            // Update animation state
            lastArrowsState = '';
        }

        // Animation state
        let animationOffset = 0;
        let lastArrowsState = '';

        // Animation loop for arrows
        function animateArrows() {
            const animLayer = document.getElementById('animationLayer');

            // Build current state string to detect changes
            const currentState = arrows.map(a =>
                `${a.id}-${a.animated}-${a.startPoint?.x}-${a.startPoint?.y}-${a.endPoint?.x}-${a.endPoint?.y}-${a.stroke}-${a.strokeWidth}`
            ).join('|');

            // Only rebuild SVG if arrows changed
            if (currentState !== lastArrowsState) {
                lastArrowsState = currentState;
                animLayer.innerHTML = '';

                arrows.forEach((arrow, index) => {
                    if (arrow.animated && arrow.visible !== false) {
                        const start = arrow.startPoint;
                        const end = arrow.endPoint;
                        if (!start || !end) return;

                        const angle = Math.atan2(end.y - start.y, end.x - start.x);
                        const headLength = 15;

                        let pathD;
                        if (arrow.hasArrowHead) {
                            const arrowHead1 = {
                                x: end.x - headLength * Math.cos(angle - Math.PI / 6),
                                y: end.y - headLength * Math.sin(angle - Math.PI / 6)
                            };
                            const arrowHead2 = {
                                x: end.x - headLength * Math.cos(angle + Math.PI / 6),
                                y: end.y - headLength * Math.sin(angle + Math.PI / 6)
                            };
                            pathD = `M ${start.x} ${start.y} L ${end.x} ${end.y} M ${end.x} ${end.y} L ${arrowHead1.x} ${arrowHead1.y} M ${end.x} ${end.y} L ${arrowHead2.x} ${arrowHead2.y}`;
                        } else {
                            pathD = `M ${start.x} ${start.y} L ${end.x} ${end.y}`;
                        }

                        const svgPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        svgPath.setAttribute('d', pathD);
                        svgPath.setAttribute('stroke', arrow.stroke);
                        svgPath.setAttribute('stroke-width', arrow.strokeWidth);
                        svgPath.setAttribute('fill', 'none');
                        svgPath.setAttribute('data-arrow-index', index);
                        // More visible animation: larger dashes with bigger gaps
                        svgPath.style.strokeDasharray = '30, 20';
                        svgPath.setAttribute('stroke-width', '4');

                        animLayer.appendChild(svgPath);
                    }
                });
            }

            // Update animation offset using JavaScript (continuous increment)
            // Higher value = faster animation
            animationOffset += 3;

            // Apply offset to all animated paths
            const paths = animLayer.querySelectorAll('path');
            paths.forEach((path, i) => {
                const arrowIndex = parseInt(path.getAttribute('data-arrow-index'));
                const arrow = arrows[arrowIndex];
                const speed = arrow?.animationSpeed || 1;
                path.style.strokeDashoffset = animationOffset * speed;
            });

            requestAnimationFrame(animateArrows);
        }
        animateArrows();

        // Update connected arrows when objects move
        canvas.on('object:moving', updateConnectedArrows);
        canvas.on('object:scaling', updateConnectedArrows);
        canvas.on('object:rotating', updateConnectedArrows);

        function updateConnectedArrows(e) {
            const obj = e.target;
            if (!obj || !obj.id) return;

            arrows.forEach(arrow => {
                let needsUpdate = false;
                let newStart = arrow.startPoint;
                let newEnd = arrow.endPoint;

                if (arrow.startObject === obj.id) {
                    const center = obj.getCenterPoint();
                    newStart = { x: center.x, y: center.y };
                    needsUpdate = true;
                }
                if (arrow.endObject === obj.id) {
                    const center = obj.getCenterPoint();
                    newEnd = { x: center.x, y: center.y };
                    needsUpdate = true;
                }

                if (needsUpdate) {
                    // Recreate arrow path
                    const angle = Math.atan2(newEnd.y - newStart.y, newEnd.x - newStart.x);
                    const headLength = 15;

                    let pathData;
                    if (arrow.hasArrowHead) {
                        const arrowHead1 = {
                            x: newEnd.x - headLength * Math.cos(angle - Math.PI / 6),
                            y: newEnd.y - headLength * Math.sin(angle - Math.PI / 6)
                        };
                        const arrowHead2 = {
                            x: newEnd.x - headLength * Math.cos(angle + Math.PI / 6),
                            y: newEnd.y - headLength * Math.sin(angle + Math.PI / 6)
                        };
                        pathData = `M ${newStart.x} ${newStart.y} L ${newEnd.x} ${newEnd.y} M ${newEnd.x} ${newEnd.y} L ${arrowHead1.x} ${arrowHead1.y} M ${newEnd.x} ${newEnd.y} L ${arrowHead2.x} ${arrowHead2.y}`;
                    } else {
                        pathData = `M ${newStart.x} ${newStart.y} L ${newEnd.x} ${newEnd.y}`;
                    }

                    // Update arrow
                    const newPath = new fabric.Path(pathData);
                    arrow.set({
                        path: newPath.path,
                        startPoint: newStart,
                        endPoint: newEnd
                    });
                }
            });
            canvas.renderAll();
        }

        // Properties panel updates
        canvas.on('selection:created', updatePropertiesPanel);
        canvas.on('selection:updated', updatePropertiesPanel);
        canvas.on('selection:cleared', clearPropertiesPanel);
        canvas.on('object:modified', updatePropertiesPanel);

        function updatePropertiesPanel() {
            const obj = canvas.getActiveObject();
            if (!obj) {
                clearPropertiesPanel();
                return;
            }

            document.getElementById('noSelection').style.display = 'none';

            if (obj.customType === 'arrow') {
                document.getElementById('objectProperties').style.display = 'none';
                document.getElementById('arrowProperties').style.display = 'block';

                document.getElementById('arrowColor').value = obj.stroke || '#4a9eff';
                document.getElementById('arrowColorText').value = obj.stroke || '#4a9eff';
                document.getElementById('arrowWidth').value = obj.strokeWidth || 3;

                const toggle = document.getElementById('animationToggle');
                toggle.classList.toggle('active', obj.animated);
                document.getElementById('speedContainer').style.display = obj.animated ? 'block' : 'none';
                document.getElementById('animationSpeed').value = obj.animationSpeed || 1;
            } else {
                document.getElementById('objectProperties').style.display = 'block';
                document.getElementById('arrowProperties').style.display = 'none';

                const bounds = obj.getBoundingRect();
                document.getElementById('propX').value = Math.round(obj.left);
                document.getElementById('propY').value = Math.round(obj.top);
                document.getElementById('propWidth').value = Math.round(obj.width * obj.scaleX);
                document.getElementById('propHeight').value = Math.round(obj.height * obj.scaleY);
                document.getElementById('propRotation').value = Math.round(obj.angle);

                if (obj.fill && typeof obj.fill === 'string') {
                    document.getElementById('propFill').value = obj.fill;
                    document.getElementById('propFillText').value = obj.fill;
                }
                if (obj.stroke) {
                    document.getElementById('propStroke').value = obj.stroke;
                    document.getElementById('propStrokeText').value = obj.stroke;
                }
                document.getElementById('propStrokeWidth').value = obj.strokeWidth || 0;

                // Show text properties if it's text
                const isText = obj.type === 'i-text' || obj.type === 'text';
                document.getElementById('textProperties').style.display = isText ? 'block' : 'none';
                if (isText) {
                    document.getElementById('propFontSize').value = obj.fontSize;
                }
            }
        }

        function clearPropertiesPanel() {
            document.getElementById('noSelection').style.display = 'block';
            document.getElementById('objectProperties').style.display = 'none';
            document.getElementById('arrowProperties').style.display = 'none';
        }

        // Property input handlers
        ['propX', 'propY', 'propWidth', 'propHeight', 'propRotation', 'propStrokeWidth', 'propFontSize'].forEach(id => {
            document.getElementById(id).addEventListener('change', function() {
                const obj = canvas.getActiveObject();
                if (!obj) return;

                switch (id) {
                    case 'propX': obj.set('left', parseFloat(this.value)); break;
                    case 'propY': obj.set('top', parseFloat(this.value)); break;
                    case 'propWidth':
                        obj.set('scaleX', parseFloat(this.value) / obj.width);
                        break;
                    case 'propHeight':
                        obj.set('scaleY', parseFloat(this.value) / obj.height);
                        break;
                    case 'propRotation': obj.set('angle', parseFloat(this.value)); break;
                    case 'propStrokeWidth': obj.set('strokeWidth', parseFloat(this.value)); break;
                    case 'propFontSize': obj.set('fontSize', parseFloat(this.value)); break;
                }
                canvas.renderAll();
                saveState();
            });
        });

        // Color inputs
        document.getElementById('propFill').addEventListener('input', function() {
            const obj = canvas.getActiveObject();
            if (obj) {
                obj.set('fill', this.value);
                document.getElementById('propFillText').value = this.value;
                canvas.renderAll();
            }
        });

        document.getElementById('propFillText').addEventListener('change', function() {
            const obj = canvas.getActiveObject();
            if (obj) {
                obj.set('fill', this.value);
                document.getElementById('propFill').value = this.value;
                canvas.renderAll();
                saveState();
            }
        });

        document.getElementById('propStroke').addEventListener('input', function() {
            const obj = canvas.getActiveObject();
            if (obj) {
                obj.set('stroke', this.value);
                document.getElementById('propStrokeText').value = this.value;
                canvas.renderAll();
            }
        });

        document.getElementById('propStrokeText').addEventListener('change', function() {
            const obj = canvas.getActiveObject();
            if (obj) {
                obj.set('stroke', this.value);
                document.getElementById('propStroke').value = this.value;
                canvas.renderAll();
                saveState();
            }
        });

        // Arrow property handlers
        document.getElementById('arrowColor').addEventListener('input', function() {
            const obj = canvas.getActiveObject();
            if (obj && obj.customType === 'arrow') {
                obj.set('stroke', this.value);
                document.getElementById('arrowColorText').value = this.value;
                canvas.renderAll();
            }
        });

        document.getElementById('arrowWidth').addEventListener('change', function() {
            const obj = canvas.getActiveObject();
            if (obj && obj.customType === 'arrow') {
                obj.set('strokeWidth', parseFloat(this.value));
                canvas.renderAll();
                saveState();
            }
        });

        // Animation toggle
        document.getElementById('animationToggle').addEventListener('click', function() {
            const obj = canvas.getActiveObject();
            if (obj && obj.customType === 'arrow') {
                obj.animated = !obj.animated;
                this.classList.toggle('active', obj.animated);
                document.getElementById('speedContainer').style.display = obj.animated ? 'block' : 'none';

                // Hide fabric.js line when animated (we draw it with SVG instead)
                obj.set('opacity', obj.animated ? 0 : 1);
                canvas.renderAll();
            }
        });

        document.getElementById('animationSpeed').addEventListener('input', function() {
            const obj = canvas.getActiveObject();
            if (obj && obj.customType === 'arrow') {
                obj.animationSpeed = parseFloat(this.value);
            }
        });

        // Delete handlers
        document.getElementById('deleteObject').addEventListener('click', deleteSelected);
        document.getElementById('deleteArrow').addEventListener('click', deleteSelected);

        function deleteSelected() {
            const obj = canvas.getActiveObject();
            if (obj) {
                if (obj.customType === 'arrow') {
                    arrows = arrows.filter(a => a !== obj);
                }
                canvas.remove(obj);
                canvas.renderAll();
                saveState();
            }
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            // Delete key
            if (e.key === 'Delete' || e.key === 'Backspace') {
                if (document.activeElement.tagName !== 'INPUT' && document.activeElement.tagName !== 'TEXTAREA') {
                    const obj = canvas.getActiveObject();
                    if (obj && !obj.isEditing) {
                        deleteSelected();
                        e.preventDefault();
                    }
                }
            }

            // Tool shortcuts
            if (document.activeElement.tagName !== 'INPUT' && document.activeElement.tagName !== 'TEXTAREA') {
                switch (e.key.toLowerCase()) {
                    case 'v':
                        document.querySelector('[data-tool="select"]').click();
                        break;
                    case 'r':
                        document.querySelector('[data-shape="rect"]').click();
                        break;
                    case 'o':
                        document.querySelector('[data-shape="circle"]').click();
                        break;
                    case 't':
                        document.querySelector('[data-shape="text"]').click();
                        break;
                    case 'a':
                        document.querySelector('[data-tool="arrow"]').click();
                        break;
                    case 'l':
                        document.querySelector('[data-tool="line"]').click();
                        break;
                    case 'd':
                        document.querySelector('[data-shape="diamond"]').click();
                        break;
                }

                // Undo/Redo
                if (e.ctrlKey || e.metaKey) {
                    if (e.key === 'z') {
                        undo();
                        e.preventDefault();
                    } else if (e.key === 'y') {
                        redo();
                        e.preventDefault();
                    }
                }
            }
        });

        // Zoom controls
        document.getElementById('zoomIn').addEventListener('click', () => {
            zoomLevel = Math.min(zoomLevel * 1.2, 5);
            canvas.setZoom(zoomLevel);
            updateZoomDisplay();
        });

        document.getElementById('zoomOut').addEventListener('click', () => {
            zoomLevel = Math.max(zoomLevel / 1.2, 0.2);
            canvas.setZoom(zoomLevel);
            updateZoomDisplay();
        });

        document.getElementById('zoomReset').addEventListener('click', () => {
            zoomLevel = 1;
            canvas.setZoom(1);
            canvas.setViewportTransform([1, 0, 0, 1, 0, 0]);
            updateZoomDisplay();
        });

        function updateZoomDisplay() {
            document.getElementById('zoomReset').textContent = Math.round(zoomLevel * 100) + '%';
        }

        // Mouse wheel zoom
        canvas.on('mouse:wheel', function(opt) {
            const delta = opt.e.deltaY;
            let newZoom = zoomLevel * (1 - delta / 500);
            newZoom = Math.min(Math.max(newZoom, 0.2), 5);

            const pointer = canvas.getPointer(opt.e);
            canvas.zoomToPoint({ x: pointer.x, y: pointer.y }, newZoom);
            zoomLevel = newZoom;
            updateZoomDisplay();

            opt.e.preventDefault();
            opt.e.stopPropagation();
        });

        // Pan with middle mouse or space+drag
        let isPanning = false;
        let lastPosX, lastPosY;

        canvas.on('mouse:down', function(opt) {
            if (opt.e.button === 1 || (opt.e.button === 0 && opt.e.altKey)) {
                isPanning = true;
                lastPosX = opt.e.clientX;
                lastPosY = opt.e.clientY;
                canvas.selection = false;
            }
        });

        canvas.on('mouse:move', function(opt) {
            if (isPanning) {
                const vpt = canvas.viewportTransform;
                vpt[4] += opt.e.clientX - lastPosX;
                vpt[5] += opt.e.clientY - lastPosY;
                canvas.requestRenderAll();
                lastPosX = opt.e.clientX;
                lastPosY = opt.e.clientY;
            }
        });

        canvas.on('mouse:up', function() {
            isPanning = false;
            canvas.selection = currentTool === 'select';
        });

        // History (Undo/Redo)
        function saveState() {
            const json = canvas.toJSON(['id', 'customType', 'hasArrowHead', 'startPoint', 'endPoint', 'startObject', 'endObject', 'animated', 'animationSpeed']);

            // Remove future states if we're not at the end
            if (historyIndex < history.length - 1) {
                history = history.slice(0, historyIndex + 1);
            }

            history.push(json);
            historyIndex = history.length - 1;

            // Limit history size
            if (history.length > 50) {
                history.shift();
                historyIndex--;
            }
        }

        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                loadState(history[historyIndex]);
            }
        }

        function redo() {
            if (historyIndex < history.length - 1) {
                historyIndex++;
                loadState(history[historyIndex]);
            }
        }

        function loadState(state) {
            canvas.loadFromJSON(state, function() {
                // Rebuild arrows array
                arrows = [];
                canvas.forEachObject(obj => {
                    if (obj.customType === 'arrow') {
                        arrows.push(obj);
                    }
                    // Set control styling
                    obj.set({
                        cornerColor: '#0066ff',
                        cornerStrokeColor: '#0066ff',
                        borderColor: '#0066ff',
                        cornerSize: 10,
                        transparentCorners: false,
                        cornerStyle: 'circle'
                    });
                });
                canvas.renderAll();
            });
        }

        document.getElementById('undo').addEventListener('click', undo);
        document.getElementById('redo').addEventListener('click', redo);

        // Export/Import
        document.getElementById('exportPNG').addEventListener('click', () => {
            const dataURL = canvas.toDataURL({
                format: 'png',
                quality: 1,
                multiplier: 2
            });
            const link = document.createElement('a');
            link.download = 'diagram.png';
            link.href = dataURL;
            link.click();
        });

        document.getElementById('exportJSON').addEventListener('click', () => {
            const json = canvas.toJSON(['id', 'customType', 'hasArrowHead', 'startPoint', 'endPoint', 'startObject', 'endObject', 'animated', 'animationSpeed']);
            const dataStr = JSON.stringify(json, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const link = document.createElement('a');
            link.download = 'diagram.json';
            link.href = URL.createObjectURL(blob);
            link.click();
        });

        document.getElementById('importJSON').addEventListener('click', () => {
            document.getElementById('jsonFileInput').click();
        });

        document.getElementById('jsonFileInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(event) {
                    try {
                        const json = JSON.parse(event.target.result);
                        loadState(json);
                        saveState();
                    } catch (err) {
                        alert('Invalid JSON file');
                    }
                };
                reader.readAsText(file);
            }
        });

        document.getElementById('clearCanvas').addEventListener('click', () => {
            if (confirm('Are you sure you want to clear the canvas?')) {
                canvas.clear();
                canvas.setBackgroundColor('#1a1a1a', canvas.renderAll.bind(canvas));
                arrows = [];
                saveState();
            }
        });

        // Context menu
        const contextMenu = document.getElementById('contextMenu');

        canvas.on('mouse:down', function(opt) {
            if (opt.e.button === 2) {
                opt.e.preventDefault();
                const target = canvas.findTarget(opt.e);
                if (target) {
                    canvas.setActiveObject(target);
                    contextMenu.style.display = 'block';
                    contextMenu.style.left = opt.e.clientX + 'px';
                    contextMenu.style.top = opt.e.clientY + 'px';
                }
            }
        });

        document.addEventListener('click', () => {
            contextMenu.style.display = 'none';
        });

        document.querySelectorAll('.context-menu-item').forEach(item => {
            item.addEventListener('click', function() {
                const action = this.dataset.action;
                const obj = canvas.getActiveObject();
                if (!obj) return;

                switch (action) {
                    case 'duplicate':
                        obj.clone(function(cloned) {
                            cloned.set({
                                left: obj.left + 20,
                                top: obj.top + 20,
                                id: (obj.customType || 'shape') + '_' + Date.now()
                            });
                            canvas.add(cloned);
                            if (cloned.customType === 'arrow') {
                                arrows.push(cloned);
                            }
                            canvas.setActiveObject(cloned);
                            canvas.renderAll();
                            saveState();
                        }, ['id', 'customType', 'hasArrowHead', 'startPoint', 'endPoint', 'animated', 'animationSpeed']);
                        break;
                    case 'bringToFront':
                        canvas.bringToFront(obj);
                        canvas.renderAll();
                        saveState();
                        break;
                    case 'sendToBack':
                        canvas.sendToBack(obj);
                        canvas.renderAll();
                        saveState();
                        break;
                    case 'delete':
                        deleteSelected();
                        break;
                }
            });
        });

        // Prevent default context menu
        canvasEl.addEventListener('contextmenu', e => e.preventDefault());

        // Initialize with select tool
        document.querySelector('[data-tool="select"]').classList.add('active');

        // Save initial state
        saveState();

        // Hide help tooltip after 5 seconds
        setTimeout(() => {
            document.getElementById('helpTooltip').style.opacity = '0';
            setTimeout(() => {
                document.getElementById('helpTooltip').style.display = 'none';
            }, 300);
        }, 5000);
    </script>
</body>
</html>
